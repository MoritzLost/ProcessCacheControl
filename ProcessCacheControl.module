<?php
namespace ProcessWire;

use ProcessWire\ProcessCacheControl\CacheControlTools;

class ProcessCacheControl extends Process implements Module
{
    public const ACTION_PARAMETER_NAME = 'action';

    public const LOG_NAME = 'cache-control';

    public static function getModuleInfo()
    {
        return [
            'title' => __('Cache Control'),
            'summary' => '',
            'author' => "Moritz L'Hoest",
            'version' => '0.1.0',
            'icon' => 'floppy-o',
            'autoload' => true,
            'useNavJSON' => true,

            'requires' => [
                'ProcessWire>=3.0.130',
                'PHP>=7.1',
            ],

            'page' => [
                'name' => 'cache-control',
                'parent' => 'setup',
                'title' => 'Cache Control',
            ],
        ];
    }

    public function init()
    {
        // add namespace to autoload module classes
        $namespace = 'ProcessWire\\ProcessCacheControl';
        $srcPath = $this->wire('config')->paths->get($this) . 'src/';
        $classLoader = $this->wire('classLoader');
        if (!$classLoader->hasNamespace($namespace)) {
            $classLoader->addNamespace($namespace, $srcPath);
        }
    }

    public function ___executeNavJSON(array $options = [])
    {
        $options['itemLabel'] = 'title';
        $options['add'] = false;
        $options['edit'] = sprintf("?%s={id}", self::ACTION_PARAMETER_NAME);
        $options['items'] = $this->getActionDefinitions();
        return parent::___executeNavJSON($options);
    }

    public function ___getActionDefinitions(): array
    {
        return [
            [
                'id' => 'all',
                'title' => __('Clear all'),
                'icon' => 'floppy-o',
                'callback' => [$this, 'clearAll'],
            ],
        ];
    }

    protected function getActionDefinitionByName(string $action): ?array
    {
        foreach ($this->getActionDefinitions() as $actionDefinition) {
            if ($actionDefinition['id'] === $action) {
                return $actionDefinition;
            }
        }
        return null;
    }

    public function ___execute()
    {
        $oldLogTotal = $this->log->getTotalEntries(self::LOG_NAME);

        $action = $this->wire('input')->get(self::ACTION_PARAMETER_NAME);
        if ($action) {
            $actionDefinition = $this->getActionDefinitionByName($action);
            if (null === $actionDefinition) {
                throw new \InvalidArgumentException(
                    sprintf($this->_('Action %s does not exist.'), $action)
                );
            }
            $this->cacheClearAction($actionDefinition);
        }

        $newLogTotal = $this->log->getTotalEntries(self::LOG_NAME);
        $newLogEntries = $this->log->getEntries(self::LOG_NAME, [
            'limit' => $newLogTotal - $oldLogTotal,
            'reverse' => false,
        ]);

        // generate module output
        $actionForm = $this->modules->get('InputfieldForm');

        // list available actions
        $buttonWrapper = $this->modules->get('InputfieldFieldset');
        $buttonWrapper->label = $this->_('Available Cache Control Actions');
        $buttonWrapper->columnWidth = 50;
        $buttonWrapper->collapsed = Inputfield::collapsedNever;
        foreach ($this->getActionDefinitions() as $actionDefinition) {
            $action = $this->modules->get('InputfieldButton');
            $action->value = $actionDefinition['title'];
            $action->href = $this->page->url(['data' => [
                'action' => $actionDefinition['id']
            ]]);
            $buttonWrapper->add($action);
        }
        $actionForm->add($buttonWrapper);

        // list current log entries
        if (count($newLogEntries) > 0) {
            $logOutput = $this->modules->get('InputfieldMarkup');
            $logOutput->label = $this->_('Log output for the current action');
            $logOutput->value = "<code><pre>" . implode("\n", array_map(function ($line) {
                return $line['text'];
            }, $newLogEntries)) . "</code></pre>";
            $logOutput->columnWidth = 50;
            $logOutput->collapsed = Inputfield::collapsedNever;
            $actionForm->add($logOutput);
        }

        return $actionForm->render();
        // @TODO build buttons for all actions
        // @TODO output log of last clearing
        return 'Hello World :)';
    }
    
    public function cacheClearAction(array $actionDefinition): void
    {
        // @TODO check permission
        call_user_func($actionDefinition['callback'], new CacheControlTools());
    }

    public function clearAll(?CacheControlTools $tools): void
    {
        // automatically instantiate $tools so the method can be called without arguments
        if (null === $tools) $tools = new CacheControlTools();

        $cache = $this->wire('cache');
        if ($this->WireCacheExpireAll) {
            $cache->expireAll();
            $this->log->save(
                self::LOG_NAME,
                $this->_('Expired all WireCache entries for an expiration data ($cache->expireAll()).')
            );
        }
        if ($this->WireCacheDeleteAll) {
            $cache->deleteAll();
            $this->log->save(
                self::LOG_NAME,
                $this->_('Deleted all WireCache entries except for reserved system entries ($cache->deleteAll()).')
            );
        }
        if ($this->WireCacheDeleteNamespaces) {
            $namespaceList = $this->parseNamespaceList($this->WireCacheDeleteNamespaces);
            if (!empty($namespaceList)) {
                $tools->clearWireCacheByNamespaces($namespaceList);
                $this->log->save(
                    self::LOG_NAME,
                    sprintf(
                        $this->_('Deleted WireCache entries for the following namespaces: %s'),
                        implode(', ', $namespaceList)
                    )
                );
            }
        }

        // Clear selected cache directories
        if ($this->ClearCacheDirectories) {
            foreach ($this->ClearCacheDirectories as $dir) {
                $tools->clearCacheDirectoryContent($dir);
            }
            $this->log->save(
                self::LOG_NAME,
                sprintf(
                    $this->_('Removed all files from the following cache directories (below %1$s): %2$s'),
                    $this->wire('config')->paths->cache,
                    implode(', ', $this->ClearCacheDirectories)
                )
            );
            if (in_array(PageRender::cacheDirName, $this->ClearCacheDirectories)) {
                $this->log->save(
                    self::LOG_NAME,
                    $this->_('Cleared the template cache.')
                );
            }
        }

        // clear cache timestamps
        if ($this->ClearAllAssetVersions) {
            $tools->clearAllAssetVersions();
        }
    }

    public function parseNamespaceList(string $namespaces) {
        return array_filter(
            preg_split("/[\r\n]+/", $namespaces),
            function ($namespace) {
                return !empty($namespace);
            }
        );
    }
}
